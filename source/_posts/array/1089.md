---
title: 1089. Duplicate Zeros
p: array/1089
date: 2019-10-22 10:59:34
tags: Array
---

## 题目

Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.

Note that elements beyond the length of the original array are not written.

Do the above modifications to the input array in place, do not return anything from your function.

Example 1:

``` Example
Input: [1,0,2,3,0,4,5,0]
Output: null
Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]
```

Note:

``` Note
1 <= arr.length <= 10000
0 <= arr[i] <= 9
```

## 分析

在数组中的每个0后面多加一个0，后面的数字依次往后推，如果数字的位置超过数组的长度，则数字被“挤出去”，不再显示。

## 题解

1. 本题的难点在于要求不能新建数组，直接在原数组中进行操作，所以先遍历一遍数组模拟增加0的操作，确定操作之后的新数组中最后一位对应的原数组下标flag，然后从flag往回依次重新填入原数组。值得注意的是如果最后一位是0，需要确定是否有空间再加一个0，在这里我用模拟操作之后的长度来确定。如果这个长度等于数组长度，则可以增加，如果大于，则不能增加。

``` java
class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        if (arr1.length == 0)
            return arr1;

        int[] arr1Flag = new int[1001];

        for (int i = 0; i < arr1.length; i++) {
            arr1Flag[arr1[i]]++;
        }

        int idx = 0;
        for (int i = 0; i < arr2.length; i++) {
            while (arr1Flag[arr2[i]] != 0) {
                arr1[idx++] = arr2[i];
                arr1Flag[arr2[i]]--;
            }
        }
        for (int i = 0; i < 1001; i++) {
            while (arr1Flag[i] != 0) {
                arr1[idx++] = i;
                arr1Flag[i]--;
            }
        }

        return arr1;
    }
}
```
