---
title: 768. Max Chunks To Make Sorted II
p: array/768
date: 2019-10-22 14:20:00
tags: Array
---

## 题目

Given an array arr of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.

What is the most number of chunks we could have made?

Example 1:

``` Example
Input: arr = [5,4,3,2,1]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.
```

Example 2:

``` Example
Input: arr = [2,1,3,4,4]
Output: 4
Explanation:
We can split into two chunks, such as [2, 1], [3, 4, 4].
However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.
```

Note:

``` Note
arr will have length in range [1, 2000].
arr[i] will be an integer in range [0, 10**8].
```

## 分析

将一个数组分成数块，每块单独排序，排完序的结果要跟整体排序结果相同。

## 题解

1. 简单粗暴的方法，首先拷贝一份原数组，然后将原数组排序，最后在拷贝的数组上面从最左边为起点开始排序，如果排序结果与排完序的原数组相同，则块数加一，从下一位开始排序，如果不同，则将和下一位一起排序，一直到排序结果跟原数组相同。(402ms)

``` java
class Solution {
    public int maxChunksToSorted(int[] arr) {
        int n = arr.length;
        if (n <= 1)
            return 1;
        
        int[] arr1 = new int[n];
        for (int i = 0; i < n; i++) arr1[i] = arr[i];
        Arrays.sort(arr);
        
        int res = 0;
        int start = 0;
        int end = 0;
        while (end < n) {
            int[] tmp = Arrays.copyOfRange(arr1, start, end+1);
            Arrays.sort(tmp);
            if (Arrays.equals(tmp, Arrays.copyOfRange(arr, start, end+1))) {
                res += 1;
                start += end - start + 1;
                end = start;
                continue;
            }
            end += 1;
        }
        
        return res;
    }
}
```

2. 本题从最左边开始计算从0到每个下标对应的最大值，然后从最右边开始计算从最右边到每个下标的最小值，如果前一个坐标的对应的最大值小于等于后一个左边的最小值，则说明前面的数字都比后面小，可以划分为一块单独排序(1ms)。

``` java
class Solution {
    public int maxChunksToSorted(int[] arr) {
        int n = arr.length;
        int[] maxOfLeft = new int[n];
        int[] minOfRight = new int[n];
        
        maxOfLeft[0] = arr[0];
        for (int i = 1; i < n; i++) {
            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);
        }
        
        minOfRight[n-1] = arr[n-1];
        for (int i = n - 2; i >= 0; i--) {
            minOfRight[i] = Math.min(minOfRight[i+1], arr[i]);
        }
        
        int res = 0;
        for (int i = 0; i < n-1; i++) {
            res += maxOfLeft[i]<=minOfRight[i+1]? 1: 0;
        }
        
        return res+1;
    }
}
```
