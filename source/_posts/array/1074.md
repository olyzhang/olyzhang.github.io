---
title: 1074. Number of Submatrices That Sum to Target
p: array/1074
date: 2019-10-22 13:29:51
tags: [Array, Matrix]
---

## 题目

Given a matrix, and a target, return the number of non-empty submatrices that sum to target.

A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.

Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.

Example 1:

``` Example
Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
Output: 4
Explanation: The four 1x1 submatrices that only contain 0.
```

Example 2:

``` Example
Input: matrix = [[1,-1],[-1,1]], target = 0
Output: 5
Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.
```

Note:

``` note
1 <= matrix.length <= 300
1 <= matrix[0].length <= 300
-1000 <= matrix[i] <= 1000
-10^8 <= target <= 10^8
```

## 分析

获取矩阵中和等于目标值的子矩阵数量，最简单粗暴的方法是将子矩阵的左上角坐标(x1,y1)和右下角坐标(x2,y2)进行遍历，这样需要四重循环，效率很低。本题的关键在于如何减少循环的数量。

## 题解

1. 新建一个同样大小的矩阵用于计算从(0,0)到对应坐标的子矩阵的和，然后用三重循环计算从(i,0)到(j,k)的子矩阵的和，k从最右边遍历到最左边，如果子矩阵(i,0,j,k1)的和等于目标值，则结果加一，如果和不等于目标值，则将和减去目标值的差值为key放到map里面，对应的value加一。如果后面有子矩阵(i,0,j,k2)的和等于这个差值，则说明子矩阵(i,k2,j,k1)的和等于目标值，结果加上map中该差值对应的value。

``` java
class Solution {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int res = 0;
        int h = matrix.length;
        int w = matrix[0].length;
        int[][] submatrixSum = new int[h][w];
        
        for (int i = 0; i < h; i++) {
            int sum = 0;
            for (int j = 0; j < w; j++) {
                sum += matrix[i][j];
                if (i == 0)
                    submatrixSum[i][j] = sum;
                else
                    submatrixSum[i][j] = submatrixSum[i-1][j] + sum;
            }
        }
        
        int total = 0;
        for (int i = 0; i < h; i++) {
            for (int j = i; j < h; j++) {
                Map<Integer, Integer> map = new HashMap<Integer, Integer>();
                for (int k = w-1; k >= 0; k--) {
                    if (i == j)
                        total = submatrixSum[i][k];
                    else
                        total = submatrixSum[j][k] - submatrixSum[i][k];
                    if (total == target)
                        res += 1;
                    if (map.containsKey(total))
                        res += map.get(total);
                    if (map.containsKey(total-target))
                        map.put(total-target, map.get(total-target)+1);
                    else
                        map.put(total-target, 1);
                }
            }
        }
        
        return res;
    }
}
```
