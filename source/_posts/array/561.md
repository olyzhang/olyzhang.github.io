---
title: 561. Array Partition I
date: 2019-09-09 17:07:08
tags: Array
---

## 题目

Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.

``` example
Input: [1,4,3,2]

Output: 4
Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
```

Note:
n is a positive integer, which is in the range of [1, 10000].
All the integers in the array will be in the range of [-10000, 10000].

## 分析

数组中两两配对，保证所有对最小值之和最大。

1. 设Sm = min(a1, b1) + min(a2, b2) + ... + min(an, bn)
2. 设Sa = a1 + b1 + a2 + b2 + ... + an + bn
3. 设Sd = |b1 - a1| + |b2 - a2| + ... + |bn - an| = d1 + d2 + ... + dn
4. Sa = a1 + a1 + d1 + a2 + a2 + d2 + ... + an + an + dn = 2Sm + Sd
5. Sm = (Sa - Sd) / 2，要使Sm最大，则Sd需要最小，也就是两点之间的距离之和最小。可知相邻两点之间的距离之和最小，一旦非相邻的两点相连，则会覆盖相邻两点的距离，这个距离势必更大。

所以该题的解法就是排序，然后将奇数位置的数字相加。

## 题解

1. 用Array.sort排序，然后把奇数位置数字相加 (15ms，超过30%)

``` java
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int result = 0;
        for (int i = 0; i < nums.length; i += 2) {
            result += nums[i];
        }
        return result;
    }
}
```

2. 看讨论区，根据数字在-10000到10000的条件，我们可以不排序，直接声明一个20001的数组，然后将奇数位置的数字相加即可 （4ms，超过99%）

``` java
class Solution {
    public int arrayPairSum(int[] nums) {
        int[] exists = new int[20001];
        for (int i = 0; i < nums.length; i++) {
            exists[nums[i]+10000]++;
        }
        
        int result = 0;
        int odd = 0;
        for (int i = 0; i < 20001; i++) {
            if (exists[i] % 2 == 1)
                odd ^= 1;
            if (odd == 1)
                result += (i - 10000) * ((exists[i] + 1) / 2);
            else
                result += (i - 10000) * (exists[i] / 2);
        }
        
        return result;
    }
}
```

``` java
class Solution {
    public int arrayPairSum(int[] nums) {
        int[] exists = new int[20001];
        for (int i = 0; i < nums.length; i++) {
            exists[nums[i]+10000]++;
        }
        
        int result = 0;
        int odd = 0;
        for (int i = 0; i < 20001; i++) {
            while (exists[i] != 0) {
                odd ^= 1;
                if (odd == 1)
                    result += i - 10000;
                exists[i]--;
            }
        }
        
        return result;
    }
}
```
